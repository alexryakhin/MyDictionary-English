package com.dor.mydictionary.ui.screens.words.wordDetails

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.dor.mydictionary.core.Difficulty
import com.dor.mydictionary.core.Tag
import com.dor.mydictionary.core.TagColor
import com.dor.mydictionary.core.Word
import com.dor.mydictionary.services.TagManager
import com.dor.mydictionary.services.WordManager
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class WordDetailsViewModel @Inject constructor(
    private val wordManager: WordManager,
    private val tagManager: TagManager
) : ViewModel() {

    private val _uiState = MutableStateFlow(WordDetailsUiState())
    val uiState: StateFlow<WordDetailsUiState> = _uiState.asStateFlow()

    fun loadWord(wordId: String) {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true, error = null) }
            
            try {
                val word = wordManager.getWordById(wordId)
                if (word != null) {
                    val tags = tagManager.getTagsForWord(wordId)
                    _uiState.update { 
                        it.copy(
                            word = word,
                            tags = tags,
                            isLoading = false,
                            error = null
                        )
                    }
                } else {
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            error = "Word not found"
                        )
                    }
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        error = "Failed to load word: ${e.message}"
                    )
                }
            }
        }
    }

    fun toggleFavorite() {
        val currentWord = _uiState.value.word ?: return
        
        viewModelScope.launch {
            try {
                val updatedWord = currentWord.copy(isFavorite = !currentWord.isFavorite)
                wordManager.updateWord(updatedWord)
                _uiState.update { it.copy(word = updatedWord) }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(error = "Failed to update favorite status: ${e.message}")
                }
            }
        }
    }

    fun updateDifficulty(difficulty: Difficulty) {
        val currentWord = _uiState.value.word ?: return
        
        viewModelScope.launch {
            try {
                val difficultyLevel = when (difficulty) {
                    Difficulty.New -> 0
                    Difficulty.InProgress -> 1
                    Difficulty.NeedsReview -> 2
                    Difficulty.Mastered -> 3
                }
                
                val updatedWord = currentWord.copy(difficultyLevel = difficultyLevel)
                wordManager.updateWord(updatedWord)
                _uiState.update { it.copy(word = updatedWord) }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(error = "Failed to update difficulty: ${e.message}")
                }
            }
        }
    }

    fun showAddTagDialog() {
        _uiState.update { it.copy(showingAddTagDialog = true) }
    }

    fun hideAddTagDialog() {
        _uiState.update { it.copy(showingAddTagDialog = false) }
    }

    fun addTag(tagName: String, tagColor: TagColor) {
        val currentWord = _uiState.value.word ?: return
        
        viewModelScope.launch {
            try {
                // Create new tag
                val newTag = Tag(
                    id = "", // Will be generated by database
                    name = tagName,
                    color = tagColor,
                    timestamp = java.util.Date()
                )
                
                val createdTag = tagManager.createTag(newTag)
                
                // Add tag to word
                tagManager.addTagToWord(currentWord.id, createdTag.id)
                
                // Reload tags for the word
                val updatedTags = tagManager.getTagsForWord(currentWord.id)
                _uiState.update { 
                    it.copy(
                        tags = updatedTags,
                        showingAddTagDialog = false
                    )
                }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        error = "Failed to add tag: ${e.message}",
                        showingAddTagDialog = false
                    )
                }
            }
        }
    }

    fun removeTag(tag: Tag) {
        val currentWord = _uiState.value.word ?: return
        
        viewModelScope.launch {
            try {
                tagManager.removeTagFromWord(currentWord.id, tag.id)
                
                // Reload tags for the word
                val updatedTags = tagManager.getTagsForWord(currentWord.id)
                _uiState.update { it.copy(tags = updatedTags) }
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(error = "Failed to remove tag: ${e.message}")
                }
            }
        }
    }

    fun playPronunciation() {
        val currentWord = _uiState.value.word ?: return
        
        viewModelScope.launch {
            try {
                // TODO: Implement TTS functionality
                // For now, just log that pronunciation was requested
                println("Playing pronunciation for: ${currentWord.wordItself}")
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(error = "Failed to play pronunciation: ${e.message}")
                }
            }
        }
    }

    fun clearError() {
        _uiState.update { it.copy(error = null) }
    }
}

data class WordDetailsUiState(
    val word: Word? = null,
    val tags: List<Tag> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val showingAddTagDialog: Boolean = false
) 